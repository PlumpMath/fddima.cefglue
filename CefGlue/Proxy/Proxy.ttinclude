<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#+

class ProxyDef
{
    private List<MethodDef> _methods;

    public ProxyDef()
    {
        _methods = new List<MethodDef>();
    }

    public string ClassName { get; set; }

    public string StructName { get; set; }

    public IEnumerable<MethodDef> GetMethods() { return _methods.AsEnumerable(); }

    public void AddMethod(string structName)
    {
        AddMethod(new MethodDef
        {
            StructName = structName
        });
    }

    public void AddMethod(MethodDef method)
    {
        method.Parent = this;
        _methods.Add(method);
    }
}

class MethodDef
{
    public MethodDef()
    {
    }

    public ProxyDef Parent { get; set; }
    public string StructName { get; set; }

    public string NativeDelegateType
    {
       get { return Parent.StructName + "." + StructName + "_delegate"; }
    }
}

void WriteProxy(ProxyDef def)
{
#>//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using Core;
	using Diagnostics;

    public sealed unsafe partial class <#=def.ClassName#> : IDisposable
	{
#if DIAGNOSTICS
		internal static int ObjectCt;
#endif

        /// <summary>
        /// Create <#=def.ClassName#> proxy from pointer.
        /// </summary>
        internal static <#=def.ClassName#> From(<#=def.StructName#>* ptr)
        {
			return new <#=def.ClassName#>(ptr, false);
        }

        /// <summary>
        /// Create <#=def.ClassName#> proxy from pointer and optionally increments the reference count for the object.
        /// </summary>
        internal static <#=def.ClassName#> Create(<#=def.StructName#>* ptr, bool addRefCount)
        {
            return new <#=def.ClassName#>(ptr, addRefCount);
        }

        private <#=def.StructName#>* ptr;

        private <#=def.ClassName#>(<#=def.StructName#>* ptr, bool addRefCount)
        {
            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Create);
#endif

			if (addRefCount) this.AddRef();
        }

        #region IDisposable
        ~<#=def.ClassName#>()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion

        private cef_base_t.add_ref_delegate add_ref
        {
            get
            {
                return (cef_base_t.add_ref_delegate)Marshal.GetDelegateForFunctionPointer(this.ptr->@base.add_ref, typeof(cef_base_t.add_ref_delegate));
            }
        }

        private cef_base_t.release_delegate release
        {
            get
            {
                return (cef_base_t.release_delegate)Marshal.GetDelegateForFunctionPointer(this.ptr->@base.release, typeof(cef_base_t.release_delegate));
            }
        }

        private cef_base_t.get_refct_delegate get_refct
        {
            get
            {
                return (cef_base_t.get_refct_delegate)Marshal.GetDelegateForFunctionPointer(this.ptr->@base.get_refct, typeof(cef_base_t.get_refct_delegate));
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return get_refct(&this.ptr->@base); }
        }

        internal <#=def.StructName#>* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal <#=def.StructName#>* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

<#+ foreach (var method in def.GetMethods()) { #>
        private <#=method.NativeDelegateType#> <#=method.StructName#>
        {
            get
            {
                return (<#=method.NativeDelegateType#>)Marshal.GetDelegateForFunctionPointer(this.ptr-><#=method.StructName#>, typeof(<#=method.NativeDelegateType#>));
            }
        }

<#+ } #>
    }
}
<#+
}
#>
