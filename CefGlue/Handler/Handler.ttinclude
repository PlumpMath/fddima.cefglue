<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#+

class HandlerDef
{
    private string className;
    private string structName;
    private List<HandlerPropertyDef> properties;

    public HandlerDef()
    {
        this.properties = new List<HandlerPropertyDef>();

		this.Disposable = false;
    }
	
	public string GetBackStoreName(string name)
	{
		return "bs_" + name;
	}

    public string ClassName
    {
        get
        {
            if (string.IsNullOrWhiteSpace(this.className))
            {
                throw new InvalidOperationException("ClassName is not set.");
            }
            return this.className;
        }
        set { this.className = value; }
    }

    public string StructName
    {
        get
        {
            if (string.IsNullOrWhiteSpace(this.structName))
            {
                throw new InvalidOperationException("ClassName is not set.");       
            }
            return this.structName;
        }
        set { this.structName = value; }
    }

	public bool ReversibleNativePointer
	{
		get; set;
	}

	/// <summary>
	/// If true - then object implement's IDisposable interface.
	/// If false - object doesn't implement IDisposable interface.
	/// In both cases class provide protected virtual Dispose(bool disposing) method.
	/// </summary>
	public bool Disposable { get; set; }

    public IEnumerable<HandlerPropertyDef> GetProperties() { return this.properties.AsEnumerable(); }

	public void AddProperty(string structName, object obj = null)
	{
		var def = new HandlerPropertyDef {
    	    StructName = structName
		};
		
		if (obj != null) {
			throw new NotImplementedException();
		}
		
		AddProperty(def);
	}
	
    public void AddProperty(HandlerPropertyDef prop)
    {
		prop.Parent = this;
        this.properties.Add(prop);
    }

    // public Action<HandlerDef> WriteFields { get; set; }
    // public Action<HandlerDef> WriteDispose { get; set; }
    // public Action<HandlerDef> WriteBody { get; set; }
    // public Action<HandlerDef> WriteImpl { get; set; }
}

class HandlerPropertyDef
{
	private string name;
	
    public HandlerPropertyDef()
    {		
    }

	public HandlerDef Parent { get; set; }
	
    public string ParentStructName { get { return this.Parent.StructName; } }

    public string Name
	{
		get
		{
			if (string.IsNullOrWhiteSpace(this.name))
			{
				this.name = string.Join("", this.StructName.Split('_').Select(_ => Capitalize(_)));
			}
			return this.name;
		}
		set
		{
			this.name = value;
		}
	}
	
    public string Summary { get; set; }
    public string StructName { get; set; }

    public virtual string Type { get { return Name + "Handler"; } }	

    public string FieldName
    {
        get
        { 
            var name = Name;
            return "_" + name.Substring(0, name.Length >= 2 ? 2 : name.Length).ToLowerInvariant()
                + name.Substring(name.Length >= 2 ? 2 : name.Length);
        }
    }

	public virtual bool DisposeField { get { return false; } }
	public virtual bool ClientCallback { get { return false; } }

    public virtual string DelegateName { get { return ParentStructName + "." + StructName + "_delegate"; } }
    public virtual string DelegateFieldName { get { return Parent.GetBackStoreName(StructName); } }

    public virtual string NativeCallbackName { get { return StructName; } }
	public virtual string NativeType { get { throw new NotSupportedException(); } }
}

void ApplyHandlerDefaults(HandlerDef def)
{
	// if (def.WriteFields == null) def.WriteFields = WriteFieldsBase;
	// if (def.WriteDispose == null) def.WriteDispose = WriteDisposeBase;
	// if (def.WriteBody == null) def.WriteBody = WriteBodyBase;
}

public static string Capitalize(string str)
{
	return char.ToUpperInvariant(str[0]) + str.Substring(1);
}

void WriteHandler(HandlerDef def)
{
	ApplyHandlerDefaults(def);
	
#>//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using Core;
    using Diagnostics;

    public abstract unsafe partial class <#=def.ClassName#> <#= def.Disposable ? ": IDisposable" : "" #>
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<<#=def.ClassName#>> pointers = new ObjectTable<<#=def.ClassName#>>();

<#+ if (def.ReversibleNativePointer) { #>
        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static <#=def.ClassName#> From(<#=def.StructName#>* pointer)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, pointer, "From");
#endif
            <#=def.ClassName#> value;
            if (pointers.TryGetValue((IntPtr)pointer, out value))
            {
                value.ReleaseRef();
                return value;
            }
            throw new CefGlueException("<#=def.ClassName#> not found.");
        }
		
<#+ } #>


        private int refct;
        private <#=def.StructName#>* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate <#=def.GetBackStoreName("add_ref")#>;
        private cef_base_t.release_delegate <#=def.GetBackStoreName("release")#>;
        private cef_base_t.get_refct_delegate <#=def.GetBackStoreName("get_refct")#>;
<#+ foreach(var prop in def.GetProperties()) { #>
        private <#=prop.DelegateName#> <#=prop.DelegateFieldName#>;
<#+ } #>

        public <#=def.ClassName#>()
        {
            this.refct = 0;
            this.ptr = <#=def.StructName#>.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Create);
#endif

            this.<#=def.GetBackStoreName("add_ref")#> = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.<#=def.GetBackStoreName("add_ref")#>);

            this.<#=def.GetBackStoreName("release")#> = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.<#=def.GetBackStoreName("release")#>);

            this.<#=def.GetBackStoreName("get_refct")#> = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.<#=def.GetBackStoreName("get_refct")#>);

<#+ foreach (var prop in def.GetProperties()) { #>
            this.<#=prop.DelegateFieldName#> = new <#=prop.DelegateName#>(this.<#=prop.NativeCallbackName#>);
            this.ptr-><#=prop.ClientCallback ? prop.NativeCallbackName : prop.StructName#> = Marshal.GetFunctionPointerForDelegate(this.<#=prop.DelegateFieldName#>);

<#+ } #>
        }

        ~<#=def.ClassName#>()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, "~<#=def.ClassName#>");
#endif
			Dispose(false);
        }

<#+ if (def.Disposable) { #>
        public void Dispose()
        {
		    if (this.RefCount == 0)
			{
			    Dispose(true);
				GC.SuppressFinalize(this);
			}
			else
			{
                this.disposed = true;
            }
        }
<#+ } #>

		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				<#=def.StructName#>.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
<#+	foreach(var prop in def.GetProperties()) { #>
<#+		if (prop.DisposeField) { #>
                if (<#=prop.FieldName#> != null) { <#=prop.FieldName#> = null; }
<#+		} #>
<#+	} #>
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal <#=def.StructName#>* NativePointer
        {
            get { return this.ptr; }
        }

        internal <#=def.StructName#>* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("<#=def.ClassName#>");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }
}
<#+
}
#>
