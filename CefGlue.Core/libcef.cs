//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue.Core
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Text;

#if !DEBUG
    [SuppressUnmanagedCodeSecurity]
#endif
    internal static unsafe partial class libcef
    {
        internal const int StructPack = 0;
        internal const CallingConvention Call = CallingConvention.Cdecl;
        internal const CallingConvention Callback = CallingConvention.StdCall;
        internal const string DllName = "libcef.dll";


        /// <summary>
        /// This function should be called on the main application thread to
        /// initialize CEF when the application is started.  A return value of
        /// true (1) indicates that it succeeded and false (0) indicates that it
        /// failed.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_initialize", CallingConvention = Call)]
        public static extern int initialize(/*const*/ cef_settings_t* settings);

        /// <summary>
        /// This function should be called on the main application thread to shut
        /// down CEF before the application exits.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_shutdown", CallingConvention = Call)]
        public static extern void shutdown();

        /// <summary>
        /// Perform a single iteration of CEF message loop processing. This
        /// function is used to integrate the CEF message loop into an existing
        /// application message loop. Care must be taken to balance performance
        /// against excessive CPU usage. This function should only be called on
        /// the main application thread and only if cef_initialize() is called
        /// with a CefSettings.multi_threaded_message_loop value of false (0).
        /// This function will not block.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_do_message_loop_work", CallingConvention = Call)]
        public static extern void do_message_loop_work();

        /// <summary>
        /// Run the CEF message loop. Use this function instead of an
        /// application- provided message loop to get the best balance between
        /// performance and CPU usage. This function should only be called on the
        /// main application thread and only if cef_initialize() is called with a
        /// CefSettings.multi_threaded_message_loop value of false (0). This
        /// function will block until a quit message is received by the system.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_run_message_loop", CallingConvention = Call)]
        public static extern void run_message_loop();

        /// <summary>
        /// Register a new V8 extension with the specified JavaScript extension
        /// code and handler. Functions implemented by the handler are prototyped
        /// using the keyword 'native'. The calling of a native function is
        /// restricted to the scope in which the prototype of the native function
        /// is defined. This function may be called on any thread.
        //
        /// Example JavaScript extension code: &lt;pre&gt;
        ///   /// create the 'example' global object if it doesn't already exist.
        ///   if (!example)
        ///     example = {};
        ///   /// create the 'example.test' global object if it doesn't already exist.
        ///   if (!example.test)
        ///     example.test = {};
        ///   (function() {
        ///     /// Define the function 'example.test.myfunction'.
        ///     example.test.myfunction = function() {
        ///       /// Call CefV8Handler::Execute() with the function name 'MyFunction'
        ///       /// and no arguments.
        ///       native function MyFunction();
        ///       return MyFunction();
        ///     };
        ///     /// Define the getter function for parameter 'example.test.myparam'.
        ///     example.test.__defineGetter__('myparam', function() {
        ///       /// Call CefV8Handler::Execute() with the function name 'GetMyParam'
        ///       /// and no arguments.
        ///       native function GetMyParam();
        ///       return GetMyParam();
        ///     });
        ///     /// Define the setter function for parameter 'example.test.myparam'.
        ///     example.test.__defineSetter__('myparam', function(b) {
        ///       /// Call CefV8Handler::Execute() with the function name 'SetMyParam'
        ///       /// and a single argument.
        ///       native function SetMyParam();
        ///       if(b) SetMyParam(b);
        ///     });
        //
        ///     /// Extension definitions can also contain normal JavaScript variables
        ///     /// and functions.
        ///     var myint = 0;
        ///     example.test.increment = function() {
        ///       myint += 1;
        ///       return myint;
        ///     };
        ///   })();
        /// &lt;/pre&gt; Example usage in the page: &lt;pre&gt;
        ///   /// Call the function.
        ///   example.test.myfunction();
        ///   /// Set the parameter.
        ///   example.test.myparam = value;
        ///   /// Get the parameter.
        ///   value = example.test.myparam;
        ///   /// Call another function.
        ///   example.test.increment();
        /// &lt;/pre&gt;
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_register_extension", CallingConvention = Call)]
        public static extern int register_extension(/*const*/ cef_string_t* extension_name, /*const*/ cef_string_t* javascript_code, cef_v8handler_t* handler);

        /// <summary>
        /// Register a custom scheme. This function should not be called for the
        /// built-in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes.
        //
        /// If |is_standard| is true (1) the scheme will be treated as a standard
        /// scheme. Standard schemes are subject to URL canonicalization and
        /// parsing rules as defined in the Common Internet Scheme Syntax RFC
        /// 1738 Section 3.1 available at http://www.ietf.org/rfc/rfc1738.txt
        //
        /// In particular, the syntax for standard scheme URLs must be of the
        /// form: &lt;pre&gt;
        ///  [scheme]://[username]:[password]@[host]:[port]/[url-path]
        /// &lt;/pre&gt; Standard scheme URLs must have a host component that is a
        /// fully qualified domain name as defined in Section 3.5 of RFC 1034
        /// [13] and Section 2.1 of RFC 1123. These URLs will be canonicalized to
        /// "scheme://host/path" in the simplest case and
        /// "scheme://username:password@host:port/path" in the most explicit
        /// case. For example, "scheme:host/path" and "scheme:///host/path" will
        /// both be canonicalized to "scheme://host/path".
        //
        /// For non-standard scheme URLs only the "scheme:" component is parsed
        /// and canonicalized. The remainder of the URL will be passed to the
        /// handler as-is. For example, "scheme:///some%20text" will remain the
        /// same. Non-standard scheme URLs cannot be used as a target for form
        /// submission.
        //
        /// If |is_local| is true (1) the scheme will be treated as local (i.e.,
        /// with the same security rules as those applied to "file" URLs). This
        /// means that normal pages cannot link to or access URLs of this scheme.
        //
        /// If |is_display_isolated| is true (1) the scheme will be treated as
        /// display- isolated. This means that pages cannot display these URLs
        /// unless they are from the same scheme. For example, pages in another
        /// origin cannot create iframes or hyperlinks to URLs with this scheme.
        //
        /// This function may be called on any thread. It should only be called
        /// once per unique |scheme_name| value. If |scheme_name| is already
        /// registered or if an error occurs this function will return false (0).
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_register_custom_scheme", CallingConvention = Call)]
        public static extern int register_custom_scheme(/*const*/ cef_string_t* scheme_name, int is_standard, int is_local, int is_display_isolated);

        /// <summary>
        /// Register a scheme handler factory for the specified |scheme_name| and
        /// optional |domain_name|. An NULL |domain_name| value for a standard
        /// scheme will cause the factory to match all domain names. The
        /// |domain_name| value will be ignored for non-standard schemes. If
        /// |scheme_name| is a built-in scheme and no handler is returned by
        /// |factory| then the built-in scheme handler factory will be called. If
        /// |scheme_name| is a custom scheme the cef_register_custom_scheme()
        /// function should be called for that scheme. This function may be
        /// called multiple times to change or remove the factory that matches
        /// the specified |scheme_name| and optional |domain_name|. Returns false
        /// (0) if an error occurs. This function may be called on any thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_register_scheme_handler_factory", CallingConvention = Call)]
        public static extern int register_scheme_handler_factory(/*const*/ cef_string_t* scheme_name, /*const*/ cef_string_t* domain_name, cef_scheme_handler_factory_t* factory);

        /// <summary>
        /// Clear all registered scheme handler factories. Returns false (0) on
        /// error. This function may be called on any thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_clear_scheme_handler_factories", CallingConvention = Call)]
        public static extern int clear_scheme_handler_factories();

        /// <summary>
        /// Add an entry to the cross-origin access whitelist.
        //
        /// The same-origin policy restricts how scripts hosted from different
        /// origins (scheme + domain) can communicate. By default, scripts can
        /// only access resources with the same origin. Scripts hosted on the
        /// HTTP and HTTPS schemes (but no other schemes) can use the "Access-
        /// Control-Allow-Origin" header to allow cross-origin requests. For
        /// example, https://source.example.com can make XMLHttpRequest requests
        /// on http://target.example.com if the http://target.example.com request
        /// returns an "Access-Control-Allow-Origin: https://source.example.com"
        /// response header.
        //
        /// Scripts in separate frames or iframes and hosted from the same
        /// protocol and domain suffix can execute cross-origin JavaScript if
        /// both pages set the document.domain value to the same domain suffix.
        /// For example, scheme://foo.example.com and scheme://bar.example.com
        /// can communicate using JavaScript if both domains set
        /// document.domain="example.com".
        //
        /// This function is used to allow access to origins that would otherwise
        /// violate the same-origin policy. Scripts hosted underneath the fully
        /// qualified |source_origin| URL (like http://www.example.com) will be
        /// allowed access to all resources hosted on the specified
        /// |target_protocol| and |target_domain|. If |allow_target_subdomains|
        /// is true (1) access will also be allowed to all subdomains of the
        /// target domain. This function may be called on any thread. Returns
        /// false (0) if |source_origin| is invalid or the whitelist cannot be
        /// accessed.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_add_cross_origin_whitelist_entry", CallingConvention = Call)]
        public static extern int add_cross_origin_whitelist_entry(/*const*/ cef_string_t* source_origin, /*const*/ cef_string_t* target_protocol, /*const*/ cef_string_t* target_domain, int allow_target_subdomains);

        /// <summary>
        /// Remove an entry from the cross-origin access whitelist. Returns false
        /// (0) if |source_origin| is invalid or the whitelist cannot be
        /// accessed.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_remove_cross_origin_whitelist_entry", CallingConvention = Call)]
        public static extern int remove_cross_origin_whitelist_entry(/*const*/ cef_string_t* source_origin, /*const*/ cef_string_t* target_protocol, /*const*/ cef_string_t* target_domain, int allow_target_subdomains);

        /// <summary>
        /// Remove all entries from the cross-origin access whitelist. Returns
        /// false (0) if the whitelist cannot be accessed.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_clear_cross_origin_whitelist", CallingConvention = Call)]
        public static extern int clear_cross_origin_whitelist();

        /// <summary>
        /// CEF maintains multiple internal threads that are used for handling
        /// different types of tasks. The UI thread creates the browser window
        /// and is used for all interaction with the WebKit rendering engine and
        /// V8 JavaScript engine (The UI thread will be the same as the main
        /// application thread if cef_initialize() is called with a
        /// CefSettings.multi_threaded_message_loop value of false (0).) The IO
        /// thread is used for handling schema and network requests. The FILE
        /// thread is used for the application cache and other miscellaneous
        /// activities. This function will return true (1) if called on the
        /// specified thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_currently_on", CallingConvention = Call)]
        public static extern int currently_on(cef_thread_id_t threadId);

        /// <summary>
        /// Post a task for execution on the specified thread. This function may
        /// be called on any thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_post_task", CallingConvention = Call)]
        public static extern int post_task(cef_thread_id_t threadId, cef_task_t* task);

        /// <summary>
        /// Post a task for delayed execution on the specified thread. This
        /// function may be called on any thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_post_delayed_task", CallingConvention = Call)]
        public static extern int post_delayed_task(cef_thread_id_t threadId, cef_task_t* task, long delay_ms);

        /// <summary>
        /// Parse the specified |url| into its component parts. Returns false (0)
        /// if the URL is NULL or invalid.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_parse_url", CallingConvention = Call)]
        public static extern int parse_url(/*const*/ cef_string_t* url, cef_urlparts_t* parts);

        /// <summary>
        /// Creates a URL from the specified |parts|, which must contain a non-
        /// NULL spec or a non-NULL host and path (at a minimum), but not both.
        /// Returns false (0) if |parts| isn't initialized as described.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_create_url", CallingConvention = Call)]
        public static extern int create_url(/*const*/ cef_urlparts_t* parts, cef_string_t* url);

        /// <summary>
        /// Visit all cookies. The returned cookies are ordered by longest path,
        /// then by earliest creation date. Returns false (0) if cookies cannot
        /// be accessed.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_visit_all_cookies", CallingConvention = Call)]
        public static extern int visit_all_cookies(cef_cookie_visitor_t* visitor);

        /// <summary>
        /// Visit a subset of cookies. The results are filtered by the given url
        /// scheme, host, domain and path. If |includeHttpOnly| is true (1) HTTP-
        /// only cookies will also be included in the results. The returned
        /// cookies are ordered by longest path, then by earliest creation date.
        /// Returns false (0) if cookies cannot be accessed.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_visit_url_cookies", CallingConvention = Call)]
        public static extern int visit_url_cookies(/*const*/ cef_string_t* url, int includeHttpOnly, cef_cookie_visitor_t* visitor);

        /// <summary>
        /// Sets a cookie given a valid URL and explicit user-provided cookie
        /// attributes. This function expects each attribute to be well-formed.
        /// It will check for disallowed characters (e.g. the ';' character is
        /// disallowed within the cookie value attribute) and will return false
        /// (0) without setting the cookie if such characters are found. This
        /// function must be called on the IO thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_set_cookie", CallingConvention = Call)]
        public static extern int set_cookie(/*const*/ cef_string_t* url, /*const*/ cef_cookie_t* cookie);

        /// <summary>
        /// Delete all cookies that match the specified parameters. If both |url|
        /// and |cookie_name| are specified all host and domain cookies matching
        /// both values will be deleted. If only |url| is specified all host
        /// cookies (but not domain cookies) irrespective of path will be
        /// deleted. If |url| is NULL all cookies for all hosts and domains will
        /// be deleted. Returns false (0) if a non-NULL invalid URL is specified
        /// or if cookies cannot be accessed. This function must be called on the
        /// IO thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_delete_cookies", CallingConvention = Call)]
        public static extern int delete_cookies(/*const*/ cef_string_t* url, /*const*/ cef_string_t* cookie_name);

    }


    /// <summary>
    /// Implement this structure for task execution. The functions of this
    /// structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_task_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Method that will be executed. |threadId| is the thread executing the
        /// call.
        /// </summary>
        public IntPtr execute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void execute_delegate(cef_task_t* self, cef_thread_id_t threadId);

    };


    /// <summary>
    /// Structure to implement for visiting cookie values. The functions of this
    /// structure will always be called on the IO thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_cookie_visitor_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Method that will be called once for each cookie. |count| is the
        /// 0-based index for the current cookie. |total| is the total number of
        /// cookies. Set |deleteCookie| to true (1) to delete the cookie
        /// currently being visited. Return false (0) to stop visiting cookies.
        /// This function may never be called if no cookies are found.
        /// </summary>
        public IntPtr visit;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int visit_delegate(cef_cookie_visitor_t* self, /*const*/ cef_cookie_t* cookie, int count, int total, int* deleteCookie);

    };


    /// <summary>
    /// Structure used to represent a browser window. The functions of this
    /// structure may be called on any thread unless otherwise indicated in the
    /// comments.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_browser_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Call this function before destroying a contained browser window. This
        /// function performs any internal cleanup that may be needed before the
        /// browser window is destroyed.
        /// </summary>
        public IntPtr parent_window_will_close;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void parent_window_will_close_delegate(cef_browser_t* self);

        /// <summary>
        /// Closes this browser window.
        /// </summary>
        public IntPtr close_browser;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void close_browser_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns true (1) if the browser can navigate backwards.
        /// </summary>
        public IntPtr can_go_back;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int can_go_back_delegate(cef_browser_t* self);

        /// <summary>
        /// Navigate backwards.
        /// </summary>
        public IntPtr go_back;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void go_back_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns true (1) if the browser can navigate forwards.
        /// </summary>
        public IntPtr can_go_forward;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int can_go_forward_delegate(cef_browser_t* self);

        /// <summary>
        /// Navigate forwards.
        /// </summary>
        public IntPtr go_forward;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void go_forward_delegate(cef_browser_t* self);

        /// <summary>
        /// Reload the current page.
        /// </summary>
        public IntPtr reload;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void reload_delegate(cef_browser_t* self);

        /// <summary>
        /// Reload the current page ignoring any cached data.
        /// </summary>
        public IntPtr reload_ignore_cache;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void reload_ignore_cache_delegate(cef_browser_t* self);

        /// <summary>
        /// Stop loading the page.
        /// </summary>
        public IntPtr stop_load;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void stop_load_delegate(cef_browser_t* self);

        /// <summary>
        /// Set focus for the browser window. If |enable| is true (1) focus will
        /// be set to the window. Otherwise, focus will be removed.
        /// </summary>
        public IntPtr set_focus;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_focus_delegate(cef_browser_t* self, int enable);

        /// <summary>
        /// Retrieve the window handle for this browser.
        /// </summary>
        public IntPtr get_window_handle;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_window_handle_t get_window_handle_delegate(cef_browser_t* self);

        /// <summary>
        /// Retrieve the window handle of the browser that opened this browser.
        /// Will return NULL for non-popup windows. This function can be used in
        /// combination with custom handling of modal windows.
        /// </summary>
        public IntPtr get_opener_window_handle;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_window_handle_t get_opener_window_handle_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns true (1) if the window is a popup window.
        /// </summary>
        public IntPtr is_popup;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_popup_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns the client for this browser.
        /// </summary>
        public IntPtr get_client;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_client_t* get_client_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns the main (top-level) frame for the browser window.
        /// </summary>
        public IntPtr get_main_frame;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_frame_t* get_main_frame_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns the focused frame for the browser window. This function
        /// should only be called on the UI thread.
        /// </summary>
        public IntPtr get_focused_frame;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_frame_t* get_focused_frame_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns the frame with the specified name, or NULL if not found. This
        /// function should only be called on the UI thread.
        /// </summary>
        public IntPtr get_frame;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_frame_t* get_frame_delegate(cef_browser_t* self, /*const*/ cef_string_t* name);

        /// <summary>
        /// Returns the names of all existing frames. This function should only
        /// be called on the UI thread.
        /// </summary>
        public IntPtr get_frame_names;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void get_frame_names_delegate(cef_browser_t* self, cef_string_list_t names);

        /// <summary>
        /// Search for |searchText|. |identifier| can be used to have multiple
        /// searches running simultaniously. |forward| indicates whether to
        /// search forward or backward within the page. |matchCase| indicates
        /// whether the search should be case-sensitive. |findNext| indicates
        /// whether this is the first request or a follow-up.
        /// </summary>
        public IntPtr find;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void find_delegate(cef_browser_t* self, int identifier, /*const*/ cef_string_t* searchText, int forward, int matchCase, int findNext);

        /// <summary>
        /// Cancel all searches that are currently going on.
        /// </summary>
        public IntPtr stop_finding;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void stop_finding_delegate(cef_browser_t* self, int clearSelection);

        /// <summary>
        /// Get the zoom level.
        /// </summary>
        public IntPtr get_zoom_level;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate double get_zoom_level_delegate(cef_browser_t* self);

        /// <summary>
        /// Change the zoom level to the specified value.
        /// </summary>
        public IntPtr set_zoom_level;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_zoom_level_delegate(cef_browser_t* self, double zoomLevel);

        /// <summary>
        /// Open developer tools in its own window.
        /// </summary>
        public IntPtr show_dev_tools;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void show_dev_tools_delegate(cef_browser_t* self);

        /// <summary>
        /// Explicitly close the developer tools window if one exists for this
        /// browser instance.
        /// </summary>
        public IntPtr close_dev_tools;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void close_dev_tools_delegate(cef_browser_t* self);

        /// <summary>
        /// Returns true (1) if window rendering is disabled.
        /// </summary>
        public IntPtr is_window_rendering_disabled;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_window_rendering_disabled_delegate(cef_browser_t* self);

        /// <summary>
        /// Get the size of the specified element. This function should only be
        /// called on the UI thread.
        /// </summary>
        public IntPtr get_size;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_size_delegate(cef_browser_t* self, cef_paint_element_type_t type, int* width, int* height);

        /// <summary>
        /// Set the size of the specified element. This function is only used
        /// when window rendering is disabled.
        /// </summary>
        public IntPtr set_size;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_size_delegate(cef_browser_t* self, cef_paint_element_type_t type, int width, int height);

        /// <summary>
        /// Returns true (1) if a popup is currently visible. This function
        /// should only be called on the UI thread.
        /// </summary>
        public IntPtr is_popup_visible;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_popup_visible_delegate(cef_browser_t* self);

        /// <summary>
        /// Hide the currently visible popup, if any.
        /// </summary>
        public IntPtr hide_popup;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void hide_popup_delegate(cef_browser_t* self);

        /// <summary>
        /// Invalidate the |dirtyRect| region of the view. This function is only
        /// used when window rendering is disabled and will result in a call to
        /// HandlePaint().
        /// </summary>
        public IntPtr invalidate;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void invalidate_delegate(cef_browser_t* self, /*const*/ cef_rect_t* dirtyRect);

        /// <summary>
        /// Get the raw image data contained in the specified element without
        /// performing validation. The specified |width| and |height| dimensions
        /// must match the current element size. On Windows |buffer| must be
        /// width*height*4 bytes in size and represents a BGRA image with an
        /// upper-left origin. This function should only be called on the UI
        /// thread.
        /// </summary>
        public IntPtr get_image;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_image_delegate(cef_browser_t* self, cef_paint_element_type_t type, int width, int height, void* buffer);

        /// <summary>
        /// Send a key event to the browser.
        /// </summary>
        public IntPtr send_key_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void send_key_event_delegate(cef_browser_t* self, cef_key_type_t type, int key, int modifiers, int sysChar, int imeChar);

        /// <summary>
        /// Send a mouse click event to the browser. The |x| and |y| coordinates
        /// are relative to the upper-left corner of the view.
        /// </summary>
        public IntPtr send_mouse_click_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void send_mouse_click_event_delegate(cef_browser_t* self, int x, int y, cef_mouse_button_type_t type, int mouseUp, int clickCount);

        /// <summary>
        /// Send a mouse move event to the browser. The |x| and |y| coordinates
        /// are relative to the upper-left corner of the view.
        /// </summary>
        public IntPtr send_mouse_move_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void send_mouse_move_event_delegate(cef_browser_t* self, int x, int y, int mouseLeave);

        /// <summary>
        /// Send a mouse wheel event to the browser. The |x| and |y| coordinates
        /// are relative to the upper-left corner of the view.
        /// </summary>
        public IntPtr send_mouse_wheel_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void send_mouse_wheel_event_delegate(cef_browser_t* self, int x, int y, int delta);

        /// <summary>
        /// Send a focus event to the browser.
        /// </summary>
        public IntPtr send_focus_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void send_focus_event_delegate(cef_browser_t* self, int setFocus);

        /// <summary>
        /// Send a capture lost event to the browser.
        /// </summary>
        public IntPtr send_capture_lost_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void send_capture_lost_event_delegate(cef_browser_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new browser window using the window parameters specified by
        /// |windowInfo|. All values will be copied internally and the actual
        /// window will be created on the UI thread. This function call will not
        /// block.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_browser_create", CallingConvention = Call)]
        public static extern int browser_create(cef_window_info_t* windowInfo, cef_client_t* client, /*const*/ cef_string_t* url, /*const*/ cef_browser_settings_t* settings);

        /// <summary>
        /// Create a new browser window using the window parameters specified by
        /// |windowInfo|. This function should only be called on the UI thread.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_browser_create_sync", CallingConvention = Call)]
        public static extern cef_browser_t* browser_create_sync(cef_window_info_t* windowInfo, cef_client_t* client, /*const*/ cef_string_t* url, /*const*/ cef_browser_settings_t* settings);

    }

    /// <summary>
    /// Structure used to represent a frame in the browser window. The functions
    /// of this structure may be called on any thread unless otherwise indicated
    /// in the comments.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_frame_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Execute undo in this frame.
        /// </summary>
        public IntPtr undo;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void undo_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute redo in this frame.
        /// </summary>
        public IntPtr redo;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void redo_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute cut in this frame.
        /// </summary>
        public IntPtr cut;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void cut_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute copy in this frame.
        /// </summary>
        public IntPtr copy;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void copy_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute paste in this frame.
        /// </summary>
        public IntPtr paste;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void paste_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute delete in this frame.
        /// </summary>
        public IntPtr del;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void del_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute select all in this frame.
        /// </summary>
        public IntPtr select_all;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void select_all_delegate(cef_frame_t* self);

        /// <summary>
        /// Execute printing in the this frame.  The user will be prompted with
        /// the print dialog appropriate to the operating system.
        /// </summary>
        public IntPtr print;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void print_delegate(cef_frame_t* self);

        /// <summary>
        /// Save this frame's HTML source to a temporary file and open it in the
        /// default text viewing application.
        /// </summary>
        public IntPtr view_source;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void view_source_delegate(cef_frame_t* self);

        /// <summary>
        /// Returns this frame's HTML source as a string. This function should
        /// only be called on the UI thread.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_source;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_source_delegate(cef_frame_t* self);

        /// <summary>
        /// Returns this frame's display text as a string. This function should
        /// only be called on the UI thread.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_text;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_text_delegate(cef_frame_t* self);

        /// <summary>
        /// Load the request represented by the |request| object.
        /// </summary>
        public IntPtr load_request;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void load_request_delegate(cef_frame_t* self, cef_request_t* request);

        /// <summary>
        /// Load the specified |url|.
        /// </summary>
        public IntPtr load_url;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void load_url_delegate(cef_frame_t* self, /*const*/ cef_string_t* url);

        /// <summary>
        /// Load the contents of |string| with the optional dummy target |url|.
        /// </summary>
        public IntPtr load_string;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void load_string_delegate(cef_frame_t* self, /*const*/ cef_string_t* @string, /*const*/ cef_string_t* url);

        /// <summary>
        /// Load the contents of |stream| with the optional dummy target |url|.
        /// </summary>
        public IntPtr load_stream;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void load_stream_delegate(cef_frame_t* self, cef_stream_reader_t* stream, /*const*/ cef_string_t* url);

        /// <summary>
        /// Execute a string of JavaScript code in this frame. The |script_url|
        /// parameter is the URL where the script in question can be found, if
        /// any. The renderer may request this URL to show the developer the
        /// source of the error.  The |start_line| parameter is the base line
        /// number to use for error reporting.
        /// </summary>
        public IntPtr execute_java_script;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void execute_java_script_delegate(cef_frame_t* self, /*const*/ cef_string_t* jsCode, /*const*/ cef_string_t* scriptUrl, int startLine);

        /// <summary>
        /// Returns true (1) if this is the main frame.
        /// </summary>
        public IntPtr is_main;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_main_delegate(cef_frame_t* self);

        /// <summary>
        /// Returns true (1) if this is the focused frame. This function should
        /// only be called on the UI thread.
        /// </summary>
        public IntPtr is_focused;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_focused_delegate(cef_frame_t* self);

        /// <summary>
        /// Returns this frame's name.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_name_delegate(cef_frame_t* self);

        /// <summary>
        /// Returns the URL currently loaded in this frame. This function should
        /// only be called on the UI thread.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_url;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_url_delegate(cef_frame_t* self);

        /// <summary>
        /// Returns the browser that this frame belongs to.
        /// </summary>
        public IntPtr get_browser;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_browser_t* get_browser_delegate(cef_frame_t* self);

        /// <summary>
        /// Visit the DOM document.
        /// </summary>
        public IntPtr visit_dom;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void visit_dom_delegate(cef_frame_t* self, cef_domvisitor_t* visitor);

    };


    /// <summary>
    /// Implement this structure to handle events related to browser life span.
    /// The functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_life_span_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called before a new popup window is created. The |parentBrowser|
        /// parameter will point to the parent browser window. The
        /// |popupFeatures| parameter will contain information about the style of
        /// popup window requested. Return false (0) to have the framework create
        /// the new popup window based on the parameters in |windowInfo|. Return
        /// true (1) to cancel creation of the popup window. By default, a newly
        /// created popup window will have the same client and settings as the
        /// parent window. To change the client for the new window modify the
        /// object that |client| points to. To change the settings for the new
        /// window modify the |settings| structure.
        /// </summary>
        public IntPtr on_before_popup;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_before_popup_delegate(cef_life_span_handler_t* self, cef_browser_t* parentBrowser, /*const*/ cef_popup_features_t* popupFeatures, cef_window_info_t* windowInfo, /*const*/ cef_string_t* url, cef_client_t** client, cef_browser_settings_t* settings);

        /// <summary>
        /// Called after a new window is created.
        /// </summary>
        public IntPtr on_after_created;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_after_created_delegate(cef_life_span_handler_t* self, cef_browser_t* browser);

        /// <summary>
        /// Called when a modal window is about to display and the modal loop
        /// should begin running. Return false (0) to use the default modal loop
        /// implementation or true (1) to use a custom implementation.
        /// </summary>
        public IntPtr run_modal;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int run_modal_delegate(cef_life_span_handler_t* self, cef_browser_t* browser);

        /// <summary>
        /// Called when a window has recieved a request to close. Return false
        /// (0) to proceed with the window close or true (1) to cancel the window
        /// close. If this is a modal window and a custom modal loop
        /// implementation was provided in run_modal() this callback should be
        /// used to restore the opener window to a usable state.
        /// </summary>
        public IntPtr do_close;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int do_close_delegate(cef_life_span_handler_t* self, cef_browser_t* browser);

        /// <summary>
        /// Called just before a window is closed. If this is a modal window and
        /// a custom modal loop implementation was provided in run_modal() this
        /// callback should be used to exit the custom modal loop.
        /// </summary>
        public IntPtr on_before_close;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_before_close_delegate(cef_life_span_handler_t* self, cef_browser_t* browser);

    };


    /// <summary>
    /// Implement this structure to handle events related to browser load status.
    /// The functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_load_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called when the browser begins loading a frame. The |frame| value
        /// will never be NULL -- call the is_main() function to check if this
        /// frame is the main frame. Multiple frames may be loading at the same
        /// time. Sub-frames may start or continue loading after the main frame
        /// load has ended. This function may not be called for a particular
        /// frame if the load request for that frame fails.
        /// </summary>
        public IntPtr on_load_start;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_load_start_delegate(cef_load_handler_t* self, cef_browser_t* browser, cef_frame_t* frame);

        /// <summary>
        /// Called when the browser is done loading a frame. The |frame| value
        /// will never be NULL -- call the is_main() function to check if this
        /// frame is the main frame. Multiple frames may be loading at the same
        /// time. Sub-frames may start or continue loading after the main frame
        /// load has ended. This function will always be called for all frames
        /// irrespective of whether the request completes successfully.
        /// </summary>
        public IntPtr on_load_end;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_load_end_delegate(cef_load_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, int httpStatusCode);

        /// <summary>
        /// Called when the browser fails to load a resource. |errorCode| is the
        /// error code number and |failedUrl| is the URL that failed to load. To
        /// provide custom error text assign the text to |errorText| and return
        /// true (1). Otherwise, return false (0) for the default error text. See
        /// net\base\net_error_list.h for complete descriptions of the error
        /// codes.
        /// </summary>
        public IntPtr on_load_error;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_load_error_delegate(cef_load_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, cef_handler_errorcode_t errorCode, /*const*/ cef_string_t* failedUrl, cef_string_t* errorText);

    };


    /// <summary>
    /// Implement this structure to handle events related to browser requests.
    /// The functions of this structure will be called on the thread indicated.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_request_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called on the UI thread before browser navigation. Return true (1) to
        /// cancel the navigation or false (0) to allow the navigation to
        /// proceed.
        /// </summary>
        public IntPtr on_before_browse;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_before_browse_delegate(cef_request_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, cef_request_t* request, cef_handler_navtype_t navType, int isRedirect);

        /// <summary>
        /// Called on the IO thread before a resource is loaded.  To allow the
        /// resource to load normally return false (0). To redirect the resource
        /// to a new url populate the |redirectUrl| value and return false (0).
        /// To specify data for the resource return a CefStream object in
        /// |resourceStream|, use the |response| object to set mime type, HTTP
        /// status code and optional header values, and return false (0). To
        /// cancel loading of the resource return true (1). Any modifications to
        /// |request| will be observed.  If the URL in |request| is changed and
        /// |redirectUrl| is also set, the URL in |request| will be used.
        /// </summary>
        public IntPtr on_before_resource_load;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_before_resource_load_delegate(cef_request_handler_t* self, cef_browser_t* browser, cef_request_t* request, cef_string_t* redirectUrl, cef_stream_reader_t** resourceStream, cef_response_t* response, int loadFlags);

        /// <summary>
        /// Called on the UI thread after a response to the resource request is
        /// received. Set |filter| if response content needs to be monitored
        /// and/or modified as it arrives.
        /// </summary>
        public IntPtr on_resource_response;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_resource_response_delegate(cef_request_handler_t* self, cef_browser_t* browser, /*const*/ cef_string_t* url, cef_response_t* response, cef_content_filter_t** filter);

        /// <summary>
        /// Called on the IO thread to handle requests for URLs with an unknown
        /// protocol component. Return true (1) to indicate that the request
        /// should succeed because it was handled externally. Set
        /// |allowOSExecution| to true (1) and return false (0) to attempt
        /// execution via the registered OS protocol handler, if any. If false
        /// (0) is returned and either |allow_os_execution| is false (0) or OS
        /// protocol handler execution fails then the request will fail with an
        /// error condition. SECURITY WARNING: YOU SHOULD USE THIS METHOD TO
        /// ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL ANALYSIS
        /// BEFORE ALLOWING OS EXECUTION.
        /// </summary>
        public IntPtr on_protocol_execution;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_protocol_execution_delegate(cef_request_handler_t* self, cef_browser_t* browser, /*const*/ cef_string_t* url, int* allowOSExecution);

        /// <summary>
        /// Called on the UI thread when a server indicates via the 'Content-
        /// Disposition' header that a response represents a file to download.
        /// |mimeType| is the mime type for the download, |fileName| is the
        /// suggested target file name and |contentLength| is either the value of
        /// the 'Content-Size' header or -1 if no size was provided. Set
        /// |handler| to the cef_download_handler_t instance that will recieve
        /// the file contents. Return true (1) to download the file or false (0)
        /// to cancel the file download.
        /// </summary>
        public IntPtr get_download_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_download_handler_delegate(cef_request_handler_t* self, cef_browser_t* browser, /*const*/ cef_string_t* mimeType, /*const*/ cef_string_t* fileName, long contentLength, cef_download_handler_t** handler);

        /// <summary>
        /// Called on the IO thread when the browser needs credentials from the
        /// user. |isProxy| indicates whether the host is a proxy server. |host|
        /// contains the hostname and port number. Set |username| and |password|
        /// and return true (1) to handle the request. Return false (0) to cancel
        /// the request.
        /// </summary>
        public IntPtr get_auth_credentials;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_auth_credentials_delegate(cef_request_handler_t* self, cef_browser_t* browser, int isProxy, /*const*/ cef_string_t* host, /*const*/ cef_string_t* realm, /*const*/ cef_string_t* scheme, cef_string_t* username, cef_string_t* password);

    };


    /// <summary>
    /// Implement this structure to handle events related to browser display
    /// state. The functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_display_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called when the navigation state has changed.
        /// </summary>
        public IntPtr on_nav_state_change;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_nav_state_change_delegate(cef_display_handler_t* self, cef_browser_t* browser, int canGoBack, int canGoForward);

        /// <summary>
        /// Called when a frame's address has changed.
        /// </summary>
        public IntPtr on_address_change;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_address_change_delegate(cef_display_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, /*const*/ cef_string_t* url);

        /// <summary>
        /// Called when the page title changes.
        /// </summary>
        public IntPtr on_title_change;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_title_change_delegate(cef_display_handler_t* self, cef_browser_t* browser, /*const*/ cef_string_t* title);

        /// <summary>
        /// Called when the browser is about to display a tooltip. |text|
        /// contains the text that will be displayed in the tooltip. To handle
        /// the display of the tooltip yourself return true (1). Otherwise, you
        /// can optionally modify |text| and then return false (0) to allow the
        /// browser to display the tooltip.
        /// </summary>
        public IntPtr on_tooltip;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_tooltip_delegate(cef_display_handler_t* self, cef_browser_t* browser, cef_string_t* text);

        /// <summary>
        /// Called when the browser receives a status message. |text| contains
        /// the text that will be displayed in the status message and |type|
        /// indicates the status message type.
        /// </summary>
        public IntPtr on_status_message;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_status_message_delegate(cef_display_handler_t* self, cef_browser_t* browser, /*const*/ cef_string_t* value, cef_handler_statustype_t type);

        /// <summary>
        /// Called to display a console message. Return true (1) to stop the
        /// message from being output to the console.
        /// </summary>
        public IntPtr on_console_message;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_console_message_delegate(cef_display_handler_t* self, cef_browser_t* browser, /*const*/ cef_string_t* message, /*const*/ cef_string_t* source, int line);

    };


    /// <summary>
    /// Implement this structure to handle events related to focus. The functions
    /// of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_focus_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called when the browser component is about to loose focus. For
        /// instance, if focus was on the last HTML element and the user pressed
        /// the TAB key. |next| will be true (1) if the browser is giving focus
        /// to the next component and false (0) if the browser is giving focus to
        /// the previous component.
        /// </summary>
        public IntPtr on_take_focus;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_take_focus_delegate(cef_focus_handler_t* self, cef_browser_t* browser, int next);

        /// <summary>
        /// Called when the browser component is requesting focus. |isWidget|
        /// will be true (1) if the focus is requested for a child widget of the
        /// browser window. Return false (0) to allow the focus to be set or true
        /// (1) to cancel setting the focus.
        /// </summary>
        public IntPtr on_set_focus;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_set_focus_delegate(cef_focus_handler_t* self, cef_browser_t* browser, int isWidget);

    };


    /// <summary>
    /// Implement this structure to handle events related to keyboard input. The
    /// functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_keyboard_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called when the browser component receives a keyboard event. |type|
        /// is the type of keyboard event, |code| is the windows scan-code for
        /// the event, |modifiers| is a set of bit-flags describing any pressed
        /// modifier keys and |isSystemKey| is true (1) if Windows considers this
        /// a 'system key' message (see http://msdn.microsoft.com/en-
        /// us/library/ms646286(VS.85).aspx). Return true (1) if the keyboard
        /// event was handled or false (0) to allow the browser component to
        /// handle the event.
        /// </summary>
        public IntPtr on_key_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_key_event_delegate(cef_keyboard_handler_t* self, cef_browser_t* browser, cef_handler_keyevent_type_t type, int code, int modifiers, int isSystemKey);

    };


    /// <summary>
    /// Implement this structure to handle events related to browser context
    /// menus. The functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_menu_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called before a context menu is displayed. Return false (0) to
        /// display the default context menu or true (1) to cancel the display.
        /// </summary>
        public IntPtr on_before_menu;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_before_menu_delegate(cef_menu_handler_t* self, cef_browser_t* browser, /*const*/ cef_handler_menuinfo_t* menuInfo);

        /// <summary>
        /// Called to optionally override the default text for a context menu
        /// item. |label| contains the default text and may be modified to
        /// substitute alternate text.
        /// </summary>
        public IntPtr get_menu_label;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void get_menu_label_delegate(cef_menu_handler_t* self, cef_browser_t* browser, cef_handler_menuid_t menuId, cef_string_t* label);

        /// <summary>
        /// Called when an option is selected from the default context menu.
        /// Return false (0) to execute the default action or true (1) to cancel
        /// the action.
        /// </summary>
        public IntPtr on_menu_action;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_menu_action_delegate(cef_menu_handler_t* self, cef_browser_t* browser, cef_handler_menuid_t menuId);

    };


    /// <summary>
    /// Implement this structure to handle events related to printing. The
    /// functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_print_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called to allow customization of standard print options before the
        /// print dialog is displayed. |printOptions| allows specification of
        /// paper size, orientation and margins. Note that the specified margins
        /// may be adjusted if they are outside the range supported by the
        /// printer. All units are in inches. Return false (0) to display the
        /// default print options or true (1) to display the modified
        /// |printOptions|.
        /// </summary>
        public IntPtr get_print_options;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_print_options_delegate(cef_print_handler_t* self, cef_browser_t* browser, cef_print_options_t* printOptions);

        /// <summary>
        /// Called to format print headers and footers. |printInfo| contains
        /// platform- specific information about the printer context. |url| is
        /// the URL if the currently printing page, |title| is the title of the
        /// currently printing page, |currentPage| is the current page number and
        /// |maxPages| is the total number of pages. Six default header locations
        /// are provided by the implementation: top left, top center, top right,
        /// bottom left, bottom center and bottom right. To use one of these
        /// default locations just assign a string to the appropriate variable.
        /// To draw the header and footer yourself return true (1). Otherwise,
        /// populate the approprate variables and return false (0).
        /// </summary>
        public IntPtr get_print_header_footer;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_print_header_footer_delegate(cef_print_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, /*const*/ cef_print_info_t* printInfo, /*const*/ cef_string_t* url, /*const*/ cef_string_t* title, int currentPage, int maxPages, cef_string_t* topLeft, cef_string_t* topCenter, cef_string_t* topRight, cef_string_t* bottomLeft, cef_string_t* bottomCenter, cef_string_t* bottomRight);

    };


    /// <summary>
    /// Implement this structure to handle events related to find results. The
    /// functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_find_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called to report find results returned by cef_browser_t::find().
        /// |identifer| is the identifier passed to cef_browser_t::find(),
        /// |count| is the number of matches currently identified,
        /// |selectionRect| is the location of where the match was found (in
        /// window coordinates), |activeMatchOrdinal| is the current position in
        /// the search results, and |finalUpdate| is true (1) if this is the last
        /// find notification.
        /// </summary>
        public IntPtr on_find_result;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_find_result_delegate(cef_find_handler_t* self, cef_browser_t* browser, int identifier, int count, /*const*/ cef_rect_t* selectionRect, int activeMatchOrdinal, int finalUpdate);

    };


    /// <summary>
    /// Implement this structure to handle events related to JavaScript dialogs.
    /// The functions of this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_jsdialog_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called  to run a JavaScript alert message. Return false (0) to
        /// display the default alert or true (1) if you displayed a custom
        /// alert.
        /// </summary>
        public IntPtr on_jsalert;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_jsalert_delegate(cef_jsdialog_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, /*const*/ cef_string_t* message);

        /// <summary>
        /// Called to run a JavaScript confirm request. Return false (0) to
        /// display the default alert or true (1) if you displayed a custom
        /// alert. If you handled the alert set |retval| to true (1) if the user
        /// accepted the confirmation.
        /// </summary>
        public IntPtr on_jsconfirm;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_jsconfirm_delegate(cef_jsdialog_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, /*const*/ cef_string_t* message, int* retval);

        /// <summary>
        /// Called to run a JavaScript prompt request. Return false (0) to
        /// display the default prompt or true (1) if you displayed a custom
        /// prompt. If you handled the prompt set |retval| to true (1) if the
        /// user accepted the prompt and request and |result| to the resulting
        /// value.
        /// </summary>
        public IntPtr on_jsprompt;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int on_jsprompt_delegate(cef_jsdialog_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, /*const*/ cef_string_t* message, /*const*/ cef_string_t* defaultValue, int* retval, cef_string_t* result);

    };


    /// <summary>
    /// Implement this structure to handle JavaScript binding. The functions of
    /// this structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_jsbinding_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called for adding values to a frame's JavaScript 'window' object.
        /// </summary>
        public IntPtr on_jsbinding;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_jsbinding_delegate(cef_jsbinding_handler_t* self, cef_browser_t* browser, cef_frame_t* frame, cef_v8value_t* @object);

    };


    /// <summary>
    /// Implement this structure to handle events when window rendering is
    /// disabled. The functions of this structure will be called on the UI
    /// thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_render_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called to retrieve the view rectangle which is relative to screen
        /// coordinates. Return true (1) if the rectangle was provided.
        /// </summary>
        public IntPtr get_view_rect;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_view_rect_delegate(cef_render_handler_t* self, cef_browser_t* browser, cef_rect_t* rect);

        /// <summary>
        /// Called to retrieve the simulated screen rectangle. Return true (1) if
        /// the rectangle was provided.
        /// </summary>
        public IntPtr get_screen_rect;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_screen_rect_delegate(cef_render_handler_t* self, cef_browser_t* browser, cef_rect_t* rect);

        /// <summary>
        /// Called to retrieve the translation from view coordinates to actual
        /// screen coordinates. Return true (1) if the screen coordinates were
        /// provided.
        /// </summary>
        public IntPtr get_screen_point;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_screen_point_delegate(cef_render_handler_t* self, cef_browser_t* browser, int viewX, int viewY, int* screenX, int* screenY);

        /// <summary>
        /// Called when the browser wants to show or hide the popup widget. The
        /// popup should be shown if |show| is true (1) and hidden if |show| is
        /// false (0).
        /// </summary>
        public IntPtr on_popup_show;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_popup_show_delegate(cef_render_handler_t* self, cef_browser_t* browser, int show);

        /// <summary>
        /// Called when the browser wants to move or resize the popup widget.
        /// |rect| contains the new location and size.
        /// </summary>
        public IntPtr on_popup_size;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_popup_size_delegate(cef_render_handler_t* self, cef_browser_t* browser, /*const*/ cef_rect_t* rect);

        /// <summary>
        /// Called when an element should be painted. |type| indicates whether
        /// the element is the view or the popup widget. |buffer| contains the
        /// pixel data for the whole image. |dirtyRect| indicates the portion of
        /// the image that has been repainted. On Windows |buffer| will be
        /// width*height*4 bytes in size and represents a BGRA image with an
        /// upper-left origin.
        /// </summary>
        public IntPtr on_paint;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_paint_delegate(cef_render_handler_t* self, cef_browser_t* browser, cef_paint_element_type_t type, /*const*/ cef_rect_t* dirtyRect, /*const*/ void* buffer);

        /// <summary>
        /// Called when the browser window's cursor has changed.
        /// </summary>
        public IntPtr on_cursor_change;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_cursor_change_delegate(cef_render_handler_t* self, cef_browser_t* browser, cef_cursor_handle_t cursor);

    };


    /// <summary>
    /// Implement this structure to provide handler implementations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_client_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Return the handler for browser life span events.
        /// </summary>
        public IntPtr get_life_span_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_life_span_handler_t* get_life_span_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for browser load status events.
        /// </summary>
        public IntPtr get_load_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_load_handler_t* get_load_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for browser request events.
        /// </summary>
        public IntPtr get_request_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_request_handler_t* get_request_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for browser display state events.
        /// </summary>
        public IntPtr get_display_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_display_handler_t* get_display_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for focus events.
        /// </summary>
        public IntPtr get_focus_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_focus_handler_t* get_focus_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for keyboard events.
        /// </summary>
        public IntPtr get_keyboard_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_keyboard_handler_t* get_keyboard_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for context menu events.
        /// </summary>
        public IntPtr get_menu_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_menu_handler_t* get_menu_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for printing events.
        /// </summary>
        public IntPtr get_print_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_print_handler_t* get_print_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for find result events.
        /// </summary>
        public IntPtr get_find_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_find_handler_t* get_find_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for JavaScript dialog events.
        /// </summary>
        public IntPtr get_jsdialog_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_jsdialog_handler_t* get_jsdialog_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for JavaScript binding events.
        /// </summary>
        public IntPtr get_jsbinding_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_jsbinding_handler_t* get_jsbinding_handler_delegate(cef_client_t* self);

        /// <summary>
        /// Return the handler for off-screen rendering events.
        /// </summary>
        public IntPtr get_render_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_render_handler_t* get_render_handler_delegate(cef_client_t* self);

    };


    /// <summary>
    /// Structure used to represent a web request. The functions of this
    /// structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_request_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Get the fully qualified URL.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_url;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_url_delegate(cef_request_t* self);

        /// <summary>
        /// Set the fully qualified URL.
        /// </summary>
        public IntPtr set_url;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_url_delegate(cef_request_t* self, /*const*/ cef_string_t* url);

        /// <summary>
        /// Get the request function type. The value will default to POST if post
        /// data is provided and GET otherwise.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_method;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_method_delegate(cef_request_t* self);

        /// <summary>
        /// Set the request function type.
        /// </summary>
        public IntPtr set_method;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_method_delegate(cef_request_t* self, /*const*/ cef_string_t* method);

        /// <summary>
        /// Get the post data.
        /// </summary>
        public IntPtr get_post_data;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_post_data_t* get_post_data_delegate(cef_request_t* self);

        /// <summary>
        /// Set the post data.
        /// </summary>
        public IntPtr set_post_data;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_post_data_delegate(cef_request_t* self, cef_post_data_t* postData);

        /// <summary>
        /// Get the header values.
        /// </summary>
        public IntPtr get_header_map;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void get_header_map_delegate(cef_request_t* self, cef_string_map_t headerMap);

        /// <summary>
        /// Set the header values.
        /// </summary>
        public IntPtr set_header_map;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_header_map_delegate(cef_request_t* self, cef_string_map_t headerMap);

        /// <summary>
        /// Set all values at one time.
        /// </summary>
        public IntPtr set;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_delegate(cef_request_t* self, /*const*/ cef_string_t* url, /*const*/ cef_string_t* method, cef_post_data_t* postData, cef_string_map_t headerMap);

        /// <summary>
        /// Get the flags used in combination with cef_web_urlrequest_t.
        /// </summary>
        public IntPtr get_flags;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_weburlrequest_flags_t get_flags_delegate(cef_request_t* self);

        /// <summary>
        /// Set the flags used in combination with cef_web_urlrequest_t.
        /// </summary>
        public IntPtr set_flags;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_flags_delegate(cef_request_t* self, cef_weburlrequest_flags_t flags);

        /// <summary>
        /// Set the URL to the first party for cookies used in combination with
        /// cef_web_urlrequest_t.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_first_party_for_cookies;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_first_party_for_cookies_delegate(cef_request_t* self);

        /// <summary>
        /// Get the URL to the first party for cookies used in combination with
        /// cef_web_urlrequest_t.
        /// </summary>
        public IntPtr set_first_party_for_cookies;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_first_party_for_cookies_delegate(cef_request_t* self, /*const*/ cef_string_t* url);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_request_t object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_request_create", CallingConvention = Call)]
        public static extern cef_request_t* request_create();

    }

    /// <summary>
    /// Structure used to represent post data for a web request. The functions of
    /// this structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_post_data_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Returns the number of existing post data elements.
        /// </summary>
        public IntPtr get_element_count;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_element_count_delegate(cef_post_data_t* self);

        /// <summary>
        /// Retrieve the post data elements.
        /// </summary>
        public IntPtr get_elements;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_post_data_element_t* get_elements_delegate(cef_post_data_t* self, int elementIndex);

        /// <summary>
        /// Remove the specified post data element.  Returns true (1) if the
        /// removal succeeds.
        /// </summary>
        public IntPtr remove_element;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int remove_element_delegate(cef_post_data_t* self, cef_post_data_element_t* element);

        /// <summary>
        /// Add the specified post data element.  Returns true (1) if the add
        /// succeeds.
        /// </summary>
        public IntPtr add_element;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int add_element_delegate(cef_post_data_t* self, cef_post_data_element_t* element);

        /// <summary>
        /// Remove all existing post data elements.
        /// </summary>
        public IntPtr remove_elements;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void remove_elements_delegate(cef_post_data_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_post_data_t object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_post_data_create", CallingConvention = Call)]
        public static extern cef_post_data_t* post_data_create();

    }

    /// <summary>
    /// Structure used to represent a single element in the request post data.
    /// The functions of this structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_post_data_element_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Remove all contents from the post data element.
        /// </summary>
        public IntPtr set_to_empty;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_to_empty_delegate(cef_post_data_element_t* self);

        /// <summary>
        /// The post data element will represent a file.
        /// </summary>
        public IntPtr set_to_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_to_file_delegate(cef_post_data_element_t* self, /*const*/ cef_string_t* fileName);

        /// <summary>
        /// The post data element will represent bytes.  The bytes passed in will
        /// be copied.
        /// </summary>
        public IntPtr set_to_bytes;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_to_bytes_delegate(cef_post_data_element_t* self, int size, /*const*/ void* bytes);

        /// <summary>
        /// Return the type of this post data element.
        /// </summary>
        public IntPtr get_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_postdataelement_type_t get_type_delegate(cef_post_data_element_t* self);

        /// <summary>
        /// Return the file name.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_file_delegate(cef_post_data_element_t* self);

        /// <summary>
        /// Return the number of bytes.
        /// </summary>
        public IntPtr get_bytes_count;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_bytes_count_delegate(cef_post_data_element_t* self);

        /// <summary>
        /// Read up to |size| bytes into |bytes| and return the number of bytes
        /// actually read.
        /// </summary>
        public IntPtr get_bytes;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_bytes_delegate(cef_post_data_element_t* self, int size, void* bytes);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_post_data_element_t object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_post_data_element_create", CallingConvention = Call)]
        public static extern cef_post_data_element_t* post_data_element_create();

    }

    /// <summary>
    /// Structure used to represent a web response. The functions of this
    /// structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_response_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Get the response status code.
        /// </summary>
        public IntPtr get_status;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_status_delegate(cef_response_t* self);

        /// <summary>
        /// Set the response status code.
        /// </summary>
        public IntPtr set_status;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_status_delegate(cef_response_t* self, int status);

        /// <summary>
        /// Get the response status text.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_status_text;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_status_text_delegate(cef_response_t* self);

        /// <summary>
        /// Set the response status text.
        /// </summary>
        public IntPtr set_status_text;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_status_text_delegate(cef_response_t* self, /*const*/ cef_string_t* statusText);

        /// <summary>
        /// Get the response mime type.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_mime_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_mime_type_delegate(cef_response_t* self);

        /// <summary>
        /// Set the response mime type.
        /// </summary>
        public IntPtr set_mime_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_mime_type_delegate(cef_response_t* self, /*const*/ cef_string_t* mimeType);

        /// <summary>
        /// Get the value for the specified response header field.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_header;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_header_delegate(cef_response_t* self, /*const*/ cef_string_t* name);

        /// <summary>
        /// Get all response header fields.
        /// </summary>
        public IntPtr get_header_map;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void get_header_map_delegate(cef_response_t* self, cef_string_map_t headerMap);

        /// <summary>
        /// Set all response header fields.
        /// </summary>
        public IntPtr set_header_map;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void set_header_map_delegate(cef_response_t* self, cef_string_map_t headerMap);

    };


    /// <summary>
    /// Structure the client can implement to provide a custom stream reader. The
    /// functions of this structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_read_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Read raw binary data.
        /// </summary>
        public IntPtr read;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int read_delegate(cef_read_handler_t* self, void* ptr, int size, int n);

        /// <summary>
        /// Seek to the specified offset position. |whence| may be any one of
        /// SEEK_CUR, SEEK_END or SEEK_SET.
        /// </summary>
        public IntPtr seek;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int seek_delegate(cef_read_handler_t* self, long offset, int whence);

        /// <summary>
        /// Return the current offset position.
        /// </summary>
        public IntPtr tell;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate long tell_delegate(cef_read_handler_t* self);

        /// <summary>
        /// Return non-zero if at end of file.
        /// </summary>
        public IntPtr eof;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int eof_delegate(cef_read_handler_t* self);

    };


    /// <summary>
    /// Structure used to read data from a stream. The functions of this
    /// structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_stream_reader_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Read raw binary data.
        /// </summary>
        public IntPtr read;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int read_delegate(cef_stream_reader_t* self, void* ptr, int size, int n);

        /// <summary>
        /// Seek to the specified offset position. |whence| may be any one of
        /// SEEK_CUR, SEEK_END or SEEK_SET. Returns zero on success and non-zero
        /// on failure.
        /// </summary>
        public IntPtr seek;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int seek_delegate(cef_stream_reader_t* self, long offset, int whence);

        /// <summary>
        /// Return the current offset position.
        /// </summary>
        public IntPtr tell;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate long tell_delegate(cef_stream_reader_t* self);

        /// <summary>
        /// Return non-zero if at end of file.
        /// </summary>
        public IntPtr eof;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int eof_delegate(cef_stream_reader_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_stream_reader_t object from a file.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_stream_reader_create_for_file", CallingConvention = Call)]
        public static extern cef_stream_reader_t* stream_reader_create_for_file(/*const*/ cef_string_t* fileName);

        /// <summary>
        /// Create a new cef_stream_reader_t object from data.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_stream_reader_create_for_data", CallingConvention = Call)]
        public static extern cef_stream_reader_t* stream_reader_create_for_data(void* data, int size);

        /// <summary>
        /// Create a new cef_stream_reader_t object from a custom handler.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_stream_reader_create_for_handler", CallingConvention = Call)]
        public static extern cef_stream_reader_t* stream_reader_create_for_handler(cef_read_handler_t* handler);

    }

    /// <summary>
    /// Structure the client can implement to provide a custom stream writer. The
    /// functions of this structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_write_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Write raw binary data.
        /// </summary>
        public IntPtr write;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int write_delegate(cef_write_handler_t* self, /*const*/ void* ptr, int size, int n);

        /// <summary>
        /// Seek to the specified offset position. |whence| may be any one of
        /// SEEK_CUR, SEEK_END or SEEK_SET.
        /// </summary>
        public IntPtr seek;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int seek_delegate(cef_write_handler_t* self, long offset, int whence);

        /// <summary>
        /// Return the current offset position.
        /// </summary>
        public IntPtr tell;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate long tell_delegate(cef_write_handler_t* self);

        /// <summary>
        /// Flush the stream.
        /// </summary>
        public IntPtr flush;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int flush_delegate(cef_write_handler_t* self);

    };


    /// <summary>
    /// Structure used to write data to a stream. The functions of this structure
    /// may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_stream_writer_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Write raw binary data.
        /// </summary>
        public IntPtr write;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int write_delegate(cef_stream_writer_t* self, /*const*/ void* ptr, int size, int n);

        /// <summary>
        /// Seek to the specified offset position. |whence| may be any one of
        /// SEEK_CUR, SEEK_END or SEEK_SET.
        /// </summary>
        public IntPtr seek;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int seek_delegate(cef_stream_writer_t* self, long offset, int whence);

        /// <summary>
        /// Return the current offset position.
        /// </summary>
        public IntPtr tell;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate long tell_delegate(cef_stream_writer_t* self);

        /// <summary>
        /// Flush the stream.
        /// </summary>
        public IntPtr flush;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int flush_delegate(cef_stream_writer_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_stream_writer_t object for a file.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_stream_writer_create_for_file", CallingConvention = Call)]
        public static extern cef_stream_writer_t* stream_writer_create_for_file(/*const*/ cef_string_t* fileName);

        /// <summary>
        /// Create a new cef_stream_writer_t object for a custom handler.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_stream_writer_create_for_handler", CallingConvention = Call)]
        public static extern cef_stream_writer_t* stream_writer_create_for_handler(cef_write_handler_t* handler);

    }

    /// <summary>
    /// Structure that encapsulates a V8 context handle.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_v8context_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Returns the browser for this context.
        /// </summary>
        public IntPtr get_browser;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_browser_t* get_browser_delegate(cef_v8context_t* self);

        /// <summary>
        /// Returns the frame for this context.
        /// </summary>
        public IntPtr get_frame;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_frame_t* get_frame_delegate(cef_v8context_t* self);

        /// <summary>
        /// Returns the global object for this context.
        /// </summary>
        public IntPtr get_global;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_v8value_t* get_global_delegate(cef_v8context_t* self);

        /// <summary>
        /// Enter this context. A context must be explicitly entered before
        /// creating a V8 Object, Array or Function asynchronously. exit() must
        /// be called the same number of times as enter() before releasing this
        /// context. V8 objects belong to the context in which they are created.
        /// Returns true (1) if the scope was entered successfully.
        /// </summary>
        public IntPtr enter;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int enter_delegate(cef_v8context_t* self);

        /// <summary>
        /// Exit this context. Call this function only after calling enter().
        /// Returns true (1) if the scope was exited successfully.
        /// </summary>
        public IntPtr exit;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int exit_delegate(cef_v8context_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Returns the current (top) context object in the V8 context stack.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8context_get_current_context", CallingConvention = Call)]
        public static extern cef_v8context_t* v8context_get_current_context();

        /// <summary>
        /// Returns the entered (bottom) context object in the V8 context stack.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8context_get_entered_context", CallingConvention = Call)]
        public static extern cef_v8context_t* v8context_get_entered_context();

    }

    /// <summary>
    /// Structure that should be implemented to handle V8 function calls. The
    /// functions of this structure will always be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_v8handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Execute with the specified argument list and return value. Return
        /// true (1) if the function was handled. To invoke V8 callback functions
        /// outside the scope of this function you need to keep references to the
        /// current V8 context (cef_v8context_t) along with any necessary
        /// callback objects.
        /// </summary>
        public IntPtr execute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int execute_delegate(cef_v8handler_t* self, /*const*/ cef_string_t* name, cef_v8value_t* @object, int argumentCount, cef_v8value_t* /*const*/ * arguments, cef_v8value_t** retval, cef_string_t* exception);

    };


    /// <summary>
    /// Structure that should be implemented to handle V8 accessor calls.
    /// Accessor identifiers are registered by calling
    /// cef_v8value_t::set_value(). The functions of this structure will always
    /// be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_v8accessor_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called to get an accessor value. |name| is the name of the property
        /// being accessed. |object| is the This() object from V8's AccessorInfo
        /// structure. |retval| is the value to return for this property. Return
        /// true (1) if handled.
        /// </summary>
        public IntPtr get;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_delegate(cef_v8accessor_t* self, /*const*/ cef_string_t* name, cef_v8value_t* @object, cef_v8value_t** retval);

        /// <summary>
        /// Called to set an accessor value. |name| is the name of the property
        /// being accessed. |value| is the new value being assigned to this
        /// property. |object| is the This() object from V8's AccessorInfo
        /// structure. Return true (1) if handled.
        /// </summary>
        public IntPtr set;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int set_delegate(cef_v8accessor_t* self, /*const*/ cef_string_t* name, cef_v8value_t* @object, cef_v8value_t* value);

    };


    /// <summary>
    /// Structure representing a V8 value. The functions of this structure should
    /// only be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_v8value_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// True if the value type is undefined.
        /// </summary>
        public IntPtr is_undefined;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_undefined_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is null.
        /// </summary>
        public IntPtr is_null;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_null_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is bool.
        /// </summary>
        public IntPtr is_bool;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_bool_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is int.
        /// </summary>
        public IntPtr is_int;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_int_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is double.
        /// </summary>
        public IntPtr is_double;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_double_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is Date.
        /// </summary>
        public IntPtr is_date;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_date_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is string.
        /// </summary>
        public IntPtr is_string;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_string_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is object.
        /// </summary>
        public IntPtr is_object;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_object_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is array.
        /// </summary>
        public IntPtr is_array;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_array_delegate(cef_v8value_t* self);

        /// <summary>
        /// True if the value type is function.
        /// </summary>
        public IntPtr is_function;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_function_delegate(cef_v8value_t* self);

        /// <summary>
        /// Returns true (1) if this object is pointing to the same handle as
        /// |that| object.
        /// </summary>
        public IntPtr is_same;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_same_delegate(cef_v8value_t* self, cef_v8value_t* that);

        /// <summary>
        /// Return a bool value.  The underlying data will be converted to if
        /// necessary.
        /// </summary>
        public IntPtr get_bool_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_bool_value_delegate(cef_v8value_t* self);

        /// <summary>
        /// Return an int value.  The underlying data will be converted to if
        /// necessary.
        /// </summary>
        public IntPtr get_int_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_int_value_delegate(cef_v8value_t* self);

        /// <summary>
        /// Return a double value.  The underlying data will be converted to if
        /// necessary.
        /// </summary>
        public IntPtr get_double_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate double get_double_value_delegate(cef_v8value_t* self);

        /// <summary>
        /// Return a Date value.  The underlying data will be converted to if
        /// necessary.
        /// </summary>
        public IntPtr get_date_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_time_t get_date_value_delegate(cef_v8value_t* self);

        /// <summary>
        /// Return a string value.  The underlying data will be converted to if
        /// necessary.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_string_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_string_value_delegate(cef_v8value_t* self);


        /// OBJECT METHODS - These functions are only available on objects.
        /// Arrays and functions are also objects. String- and integer-based keys
        /// can be used interchangably with the framework converting between them
        /// as necessary. Keys beginning with "Cef::" and "v8::" are reserved by
        /// the system.

        /// <summary>
        /// Returns true (1) if the object has a value with the specified
        /// identifier.
        /// </summary>
        public IntPtr has_value_bykey;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_value_bykey_delegate(cef_v8value_t* self, /*const*/ cef_string_t* key);

        /// <summary>
        /// Returns true (1) if the object has a value with the specified
        /// identifier.
        /// </summary>
        public IntPtr has_value_byindex;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_value_byindex_delegate(cef_v8value_t* self, int index);

        /// <summary>
        /// Delete the value with the specified identifier.
        /// </summary>
        public IntPtr delete_value_bykey;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int delete_value_bykey_delegate(cef_v8value_t* self, /*const*/ cef_string_t* key);

        /// <summary>
        /// Delete the value with the specified identifier.
        /// </summary>
        public IntPtr delete_value_byindex;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int delete_value_byindex_delegate(cef_v8value_t* self, int index);

        /// <summary>
        /// Returns the value with the specified identifier.
        /// </summary>
        public IntPtr get_value_bykey;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_v8value_t* get_value_bykey_delegate(cef_v8value_t* self, /*const*/ cef_string_t* key);

        /// <summary>
        /// Returns the value with the specified identifier.
        /// </summary>
        public IntPtr get_value_byindex;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_v8value_t* get_value_byindex_delegate(cef_v8value_t* self, int index);

        /// <summary>
        /// Associate a value with the specified identifier.
        /// </summary>
        public IntPtr set_value_bykey;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int set_value_bykey_delegate(cef_v8value_t* self, /*const*/ cef_string_t* key, cef_v8value_t* value);

        /// <summary>
        /// Associate a value with the specified identifier.
        /// </summary>
        public IntPtr set_value_byindex;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int set_value_byindex_delegate(cef_v8value_t* self, int index, cef_v8value_t* value);

        /// <summary>
        /// Register an identifier whose access will be forwarded to the
        /// cef_v8accessor_t instance passed to
        /// cef_v8value_t::cef_v8value_create_object_with_accessor().
        /// </summary>
        public IntPtr set_value_byaccessor;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int set_value_byaccessor_delegate(cef_v8value_t* self, /*const*/ cef_string_t* key, cef_v8_accesscontrol_t settings, cef_v8_propertyattribute_t attribute);

        /// <summary>
        /// Read the keys for the object's values into the specified vector.
        /// Integer- based keys will also be returned as strings.
        /// </summary>
        public IntPtr get_keys;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_keys_delegate(cef_v8value_t* self, cef_string_list_t keys);

        /// <summary>
        /// Returns the user data, if any, specified when the object was created.
        /// </summary>
        public IntPtr get_user_data;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_base_t* get_user_data_delegate(cef_v8value_t* self);


        /// ARRAY METHODS - These functions are only available on arrays.

        /// <summary>
        /// Returns the number of elements in the array.
        /// </summary>
        public IntPtr get_array_length;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_array_length_delegate(cef_v8value_t* self);


        /// FUNCTION METHODS - These functions are only available on functions.

        /// <summary>
        /// Returns the function name.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_function_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_function_name_delegate(cef_v8value_t* self);

        /// <summary>
        /// Returns the function handler or NULL if not a CEF-created function.
        /// </summary>
        public IntPtr get_function_handler;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_v8handler_t* get_function_handler_delegate(cef_v8value_t* self);

        /// <summary>
        /// Execute the function using the current V8 context.
        /// </summary>
        public IntPtr execute_function;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int execute_function_delegate(cef_v8value_t* self, cef_v8value_t* @object, int argumentCount, cef_v8value_t* /*const*/ * arguments, cef_v8value_t** retval, cef_string_t* exception);

        /// <summary>
        /// Execute the function using the specified V8 context.
        /// </summary>
        public IntPtr execute_function_with_context;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int execute_function_with_context_delegate(cef_v8value_t* self, cef_v8context_t* context, cef_v8value_t* @object, int argumentCount, cef_v8value_t* /*const*/ * arguments, cef_v8value_t** retval, cef_string_t* exception);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_v8value_t object of type undefined.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_undefined", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_undefined();

        /// <summary>
        /// Create a new cef_v8value_t object of type null.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_null", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_null();

        /// <summary>
        /// Create a new cef_v8value_t object of type bool.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_bool", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_bool(int value);

        /// <summary>
        /// Create a new cef_v8value_t object of type int.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_int", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_int(int value);

        /// <summary>
        /// Create a new cef_v8value_t object of type double.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_double", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_double(double value);

        /// <summary>
        /// Create a new cef_v8value_t object of type Date.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_date", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_date(/*const*/ cef_time_t* date);

        /// <summary>
        /// Create a new cef_v8value_t object of type string.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_string", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_string(/*const*/ cef_string_t* value);

        /// <summary>
        /// Create a new cef_v8value_t object of type object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_object", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_object(cef_base_t* user_data);

        /// <summary>
        /// Create a new cef_v8value_t object of type object with accessors.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_object_with_accessor", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_object_with_accessor(cef_base_t* user_data, cef_v8accessor_t* accessor);

        /// <summary>
        /// Create a new cef_v8value_t object of type array.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_array", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_array();

        /// <summary>
        /// Create a new cef_v8value_t object of type function.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_v8value_create_function", CallingConvention = Call)]
        public static extern cef_v8value_t* v8value_create_function(/*const*/ cef_string_t* name, cef_v8handler_t* handler);

    }

    /// <summary>
    /// Structure that creates cef_scheme_handler_t instances. The functions of
    /// this structure will always be called on the IO thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_scheme_handler_factory_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Return a new scheme handler instance to handle the request.
        /// </summary>
        public IntPtr create;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_scheme_handler_t* create_delegate(cef_scheme_handler_factory_t* self, /*const*/ cef_string_t* scheme_name, cef_request_t* request);

    };


    /// <summary>
    /// Structure used to represent a custom scheme handler structure. The
    /// functions of this structure will always be called on the IO thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_scheme_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Process the request. All response generation should take place in
        /// this function. If there is no response set |response_length| to zero
        /// or return false (0) and read_response() will not be called. If the
        /// response length is not known set |response_length| to -1 and
        /// read_response() will be called until it returns false (0) or until
        /// the value of |bytes_read| is set to 0. If the response length is
        /// known set |response_length| to a positive value and read_response()
        /// will be called until it returns false (0), the value of |bytes_read|
        /// is set to 0 or the specified number of bytes have been read. Use the
        /// |response| object to set the mime type, http status code and optional
        /// header values for the response and return true (1). To redirect the
        /// request to a new URL set |redirectUrl| to the new URL and return true
        /// (1).
        /// </summary>
        public IntPtr process_request;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int process_request_delegate(cef_scheme_handler_t* self, cef_request_t* request, cef_string_t* redirectUrl, cef_response_t* response, int* response_length);

        /// <summary>
        /// Cancel processing of the request.
        /// </summary>
        public IntPtr cancel;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void cancel_delegate(cef_scheme_handler_t* self);

        /// <summary>
        /// Copy up to |bytes_to_read| bytes into |data_out|. If the copy
        /// succeeds set |bytes_read| to the number of bytes copied and return
        /// true (1). If the copy fails return false (0) and read_response() will
        /// not be called again.
        /// </summary>
        public IntPtr read_response;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int read_response_delegate(cef_scheme_handler_t* self, void* data_out, int bytes_to_read, int* bytes_read);

    };


    /// <summary>
    /// Structure used to handle file downloads. The functions of this structure
    /// will always be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_download_handler_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// A portion of the file contents have been received. This function will
        /// be called multiple times until the download is complete. Return |true
        /// (1)| to continue receiving data and |false (0)| to cancel.
        /// </summary>
        public IntPtr received_data;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int received_data_delegate(cef_download_handler_t* self, void* data, int data_size);

        /// <summary>
        /// The download is complete.
        /// </summary>
        public IntPtr complete;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void complete_delegate(cef_download_handler_t* self);

    };


    /// <summary>
    /// Structure used to make a Web URL request. Web URL requests are not
    /// associated with a browser instance so no cef_client_t callbacks will be
    /// executed. The functions of this structure may be called on any thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_web_urlrequest_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Cancels the request.
        /// </summary>
        public IntPtr cancel;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void cancel_delegate(cef_web_urlrequest_t* self);

        /// <summary>
        /// Returns the current ready state of the request.
        /// </summary>
        public IntPtr get_state;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_weburlrequest_state_t get_state_delegate(cef_web_urlrequest_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new CefWebUrlRequest object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_web_urlrequest_create", CallingConvention = Call)]
        public static extern cef_web_urlrequest_t* web_urlrequest_create(cef_request_t* request, cef_web_urlrequest_client_t* client);

    }

    /// <summary>
    /// Structure that should be implemented by the cef_web_urlrequest_t client.
    /// The functions of this structure will always be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_web_urlrequest_client_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Notifies the client that the request state has changed. State change
        /// notifications will always be sent before the below notification
        /// functions are called.
        /// </summary>
        public IntPtr on_state_change;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_state_change_delegate(cef_web_urlrequest_client_t* self, cef_web_urlrequest_t* requester, cef_weburlrequest_state_t state);

        /// <summary>
        /// Notifies the client that the request has been redirected and
        /// provides a chance to change the request parameters.
        /// </summary>
        public IntPtr on_redirect;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_redirect_delegate(cef_web_urlrequest_client_t* self, cef_web_urlrequest_t* requester, cef_request_t* request, cef_response_t* response);

        /// <summary>
        /// Notifies the client of the response data.
        /// </summary>
        public IntPtr on_headers_received;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_headers_received_delegate(cef_web_urlrequest_client_t* self, cef_web_urlrequest_t* requester, cef_response_t* response);

        /// <summary>
        /// Notifies the client of the upload progress.
        /// </summary>
        public IntPtr on_progress;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_progress_delegate(cef_web_urlrequest_client_t* self, cef_web_urlrequest_t* requester, ulong bytesSent, ulong totalBytesToBeSent);

        /// <summary>
        /// Notifies the client that content has been received.
        /// </summary>
        public IntPtr on_data;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_data_delegate(cef_web_urlrequest_client_t* self, cef_web_urlrequest_t* requester, /*const*/ void* data, int dataLength);

        /// <summary>
        /// Notifies the client that the request ended with an error.
        /// </summary>
        public IntPtr on_error;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void on_error_delegate(cef_web_urlrequest_client_t* self, cef_web_urlrequest_t* requester, cef_handler_errorcode_t errorCode);

    };


    /// <summary>
    /// Structure that supports the reading of XML data via the libxml streaming
    /// API. The functions of this structure should only be called on the thread
    /// that creates the object.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_xml_reader_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Moves the cursor to the next node in the document. This function must
        /// be called at least once to set the current cursor position. Returns
        /// true (1) if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_next_node;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_next_node_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Close the document. This should be called directly to ensure that
        /// cleanup occurs on the correct thread.
        /// </summary>
        public IntPtr close;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int close_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns true (1) if an error has been reported by the XML parser.
        /// </summary>
        public IntPtr has_error;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_error_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the error string.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_error;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_error_delegate(cef_xml_reader_t* self);


        /// The below functions retrieve data for the node at the current cursor
        /// position.

        /// <summary>
        /// Returns the node type.
        /// </summary>
        public IntPtr get_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_xml_node_type_t get_type_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the node depth. Depth starts at 0 for the root node.
        /// </summary>
        public IntPtr get_depth;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_depth_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the local name. See http://www.w3.org/TR/REC-xml-names/#NT-
        /// LocalPart for additional details.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_local_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_local_name_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the namespace prefix. See http://www.w3.org/TR/REC-xml-names/
        /// for additional details.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_prefix;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_prefix_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the qualified name, equal to (Prefix:)LocalName. See
        /// http://www.w3.org/TR/REC-xml-names/#ns-qualnames for additional
        /// details.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_qualified_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_qualified_name_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the URI defining the namespace associated with the node. See
        /// http://www.w3.org/TR/REC-xml-names/ for additional details.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_namespace_uri;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_namespace_uri_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the base URI of the node. See http://www.w3.org/TR/xmlbase/
        /// for additional details.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_base_uri;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_base_uri_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the xml:lang scope within which the node resides. See
        /// http://www.w3.org/TR/REC-xml/#sec-lang-tag for additional details.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_xml_lang;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_xml_lang_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns true (1) if the node represents an NULL element. &lt;a/&gt; is
        /// considered NULL but &lt;a&gt;&lt;/a&gt; is not.
        /// </summary>
        public IntPtr is_empty_element;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_empty_element_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns true (1) if the node has a text value.
        /// </summary>
        public IntPtr has_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_value_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the text value.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_value_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns true (1) if the node has attributes.
        /// </summary>
        public IntPtr has_attributes;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_attributes_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the number of attributes.
        /// </summary>
        public IntPtr get_attribute_count;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_attribute_count_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the value of the attribute at the specified 0-based index.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_attribute_byindex;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_attribute_byindex_delegate(cef_xml_reader_t* self, int index);

        /// <summary>
        /// Returns the value of the attribute with the specified qualified name.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_attribute_byqname;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_attribute_byqname_delegate(cef_xml_reader_t* self, /*const*/ cef_string_t* qualifiedName);

        /// <summary>
        /// Returns the value of the attribute with the specified local name and
        /// namespace URI.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_attribute_bylname;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_attribute_bylname_delegate(cef_xml_reader_t* self, /*const*/ cef_string_t* localName, /*const*/ cef_string_t* namespaceURI);

        /// <summary>
        /// Returns an XML representation of the current node's children.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_inner_xml;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_inner_xml_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns an XML representation of the current node including its
        /// children.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_outer_xml;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_outer_xml_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Returns the line number for the current node.
        /// </summary>
        public IntPtr get_line_number;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_line_number_delegate(cef_xml_reader_t* self);


        /// Attribute nodes are not traversed by default. The below functions can
        /// be used to move the cursor to an attribute node.
        /// move_to_carrying_element() can be called afterwards to return the
        /// cursor to the carrying element. The depth of an attribute node will
        /// be 1 + the depth of the carrying element.

        /// <summary>
        /// Moves the cursor to the attribute at the specified 0-based index.
        /// Returns true (1) if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_attribute_byindex;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_attribute_byindex_delegate(cef_xml_reader_t* self, int index);

        /// <summary>
        /// Moves the cursor to the attribute with the specified qualified name.
        /// Returns true (1) if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_attribute_byqname;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_attribute_byqname_delegate(cef_xml_reader_t* self, /*const*/ cef_string_t* qualifiedName);

        /// <summary>
        /// Moves the cursor to the attribute with the specified local name and
        /// namespace URI. Returns true (1) if the cursor position was set
        /// successfully.
        /// </summary>
        public IntPtr move_to_attribute_bylname;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_attribute_bylname_delegate(cef_xml_reader_t* self, /*const*/ cef_string_t* localName, /*const*/ cef_string_t* namespaceURI);

        /// <summary>
        /// Moves the cursor to the first attribute in the current element.
        /// Returns true (1) if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_first_attribute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_first_attribute_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Moves the cursor to the next attribute in the current element.
        /// Returns true (1) if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_next_attribute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_next_attribute_delegate(cef_xml_reader_t* self);

        /// <summary>
        /// Moves the cursor back to the carrying element. Returns true (1) if
        /// the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_carrying_element;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_carrying_element_delegate(cef_xml_reader_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_xml_reader_t object. The returned object's functions
        /// can only be called from the thread that created the object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_xml_reader_create", CallingConvention = Call)]
        public static extern cef_xml_reader_t* xml_reader_create(cef_stream_reader_t* stream, cef_xml_encoding_type_t encodingType, /*const*/ cef_string_t* URI);

    }

    /// <summary>
    /// Structure that supports the reading of zip archives via the zlib unzip
    /// API. The functions of this structure should only be called on the thread
    /// that creates the object.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_zip_reader_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Moves the cursor to the first file in the archive. Returns true (1)
        /// if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_first_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_first_file_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Moves the cursor to the next file in the archive. Returns true (1) if
        /// the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_next_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_next_file_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Moves the cursor to the specified file in the archive. If
        /// |caseSensitive| is true (1) then the search will be case sensitive.
        /// Returns true (1) if the cursor position was set successfully.
        /// </summary>
        public IntPtr move_to_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int move_to_file_delegate(cef_zip_reader_t* self, /*const*/ cef_string_t* fileName, int caseSensitive);

        /// <summary>
        /// Closes the archive. This should be called directly to ensure that
        /// cleanup occurs on the correct thread.
        /// </summary>
        public IntPtr close;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int close_delegate(cef_zip_reader_t* self);


        /// The below functions act on the file at the current cursor position.

        /// <summary>
        /// Returns the name of the file.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_file_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_file_name_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Returns the uncompressed size of the file.
        /// </summary>
        public IntPtr get_file_size;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate long get_file_size_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Returns the last modified timestamp for the file.
        /// </summary>
        public IntPtr get_file_last_modified;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate time_t get_file_last_modified_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Opens the file for reading of uncompressed data. A read password may
        /// optionally be specified.
        /// </summary>
        public IntPtr open_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int open_file_delegate(cef_zip_reader_t* self, /*const*/ cef_string_t* password);

        /// <summary>
        /// Closes the file.
        /// </summary>
        public IntPtr close_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int close_file_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Read uncompressed file contents into the specified buffer. Returns &lt;
        /// 0 if an error occurred, 0 if at the end of file, or the number of
        /// bytes read.
        /// </summary>
        public IntPtr read_file;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int read_file_delegate(cef_zip_reader_t* self, void* buffer, int bufferSize);

        /// <summary>
        /// Returns the current offset in the uncompressed file contents.
        /// </summary>
        public IntPtr tell;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate long tell_delegate(cef_zip_reader_t* self);

        /// <summary>
        /// Returns true (1) if at end of the file contents.
        /// </summary>
        public IntPtr eof;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int eof_delegate(cef_zip_reader_t* self);

    };

    internal static unsafe partial class libcef
    {

        /// <summary>
        /// Create a new cef_zip_reader_t object. The returned object's functions
        /// can only be called from the thread that created the object.
        /// </summary>
        [DllImport(DllName, EntryPoint = "cef_zip_reader_create", CallingConvention = Call)]
        public static extern cef_zip_reader_t* zip_reader_create(cef_stream_reader_t* stream);

    }

    /// <summary>
    /// Structure to implement for visiting the DOM. The functions of this
    /// structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_domvisitor_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Method executed for visiting the DOM. The document object passed to
        /// this function represents a snapshot of the DOM at the time this
        /// function is executed. DOM objects are only valid for the scope of
        /// this function. Do not keep references to or attempt to access any DOM
        /// objects outside the scope of this function.
        /// </summary>
        public IntPtr visit;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void visit_delegate(cef_domvisitor_t* self, cef_domdocument_t* document);

    };


    /// <summary>
    /// Structure used to represent a DOM document. The functions of this
    /// structure should only be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_domdocument_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Returns the document type.
        /// </summary>
        public IntPtr get_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_dom_document_type_t get_type_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the root document node.
        /// </summary>
        public IntPtr get_document;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_document_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the BODY node of an HTML document.
        /// </summary>
        public IntPtr get_body;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_body_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the HEAD node of an HTML document.
        /// </summary>
        public IntPtr get_head;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_head_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the title of an HTML document.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_title;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_title_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the document element with the specified ID value.
        /// </summary>
        public IntPtr get_element_by_id;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_element_by_id_delegate(cef_domdocument_t* self, /*const*/ cef_string_t* id);

        /// <summary>
        /// Returns the node that currently has keyboard focus.
        /// </summary>
        public IntPtr get_focused_node;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_focused_node_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns true (1) if a portion of the document is selected.
        /// </summary>
        public IntPtr has_selection;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_selection_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the selection start node.
        /// </summary>
        public IntPtr get_selection_start_node;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_selection_start_node_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the selection offset within the start node.
        /// </summary>
        public IntPtr get_selection_start_offset;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_selection_start_offset_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the selection end node.
        /// </summary>
        public IntPtr get_selection_end_node;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_selection_end_node_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the selection offset within the end node.
        /// </summary>
        public IntPtr get_selection_end_offset;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int get_selection_end_offset_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the contents of this selection as markup.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_selection_as_markup;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_selection_as_markup_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the contents of this selection as text.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_selection_as_text;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_selection_as_text_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns the base URL for the document.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_base_url;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_base_url_delegate(cef_domdocument_t* self);

        /// <summary>
        /// Returns a complete URL based on the document base URL and the
        /// specified partial URL.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_complete_url;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_complete_url_delegate(cef_domdocument_t* self, /*const*/ cef_string_t* partialURL);

    };


    /// <summary>
    /// Structure used to represent a DOM node. The functions of this structure
    /// should only be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_domnode_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Returns the type for this node.
        /// </summary>
        public IntPtr get_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_dom_node_type_t get_type_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns true (1) if this is a text node.
        /// </summary>
        public IntPtr is_text;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_text_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns true (1) if this is an element node.
        /// </summary>
        public IntPtr is_element;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_element_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns true (1) if this object is pointing to the same handle as
        /// |that| object.
        /// </summary>
        public IntPtr is_same;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int is_same_delegate(cef_domnode_t* self, cef_domnode_t* that);

        /// <summary>
        /// Returns the name of this node.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_name_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns the value of this node.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_value_delegate(cef_domnode_t* self);

        /// <summary>
        /// Set the value of this node. Returns true (1) on success.
        /// </summary>
        public IntPtr set_value;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int set_value_delegate(cef_domnode_t* self, /*const*/ cef_string_t* value);

        /// <summary>
        /// Returns the contents of this node as markup.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_as_markup;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_as_markup_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns the document associated with this node.
        /// </summary>
        public IntPtr get_document;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domdocument_t* get_document_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns the parent node.
        /// </summary>
        public IntPtr get_parent;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_parent_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns the previous sibling node.
        /// </summary>
        public IntPtr get_previous_sibling;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_previous_sibling_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns the next sibling node.
        /// </summary>
        public IntPtr get_next_sibling;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_next_sibling_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns true (1) if this node has child nodes.
        /// </summary>
        public IntPtr has_children;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_children_delegate(cef_domnode_t* self);

        /// <summary>
        /// Return the first child node.
        /// </summary>
        public IntPtr get_first_child;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_first_child_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns the last child node.
        /// </summary>
        public IntPtr get_last_child;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_last_child_delegate(cef_domnode_t* self);

        /// <summary>
        /// Add an event listener to this node for the specified event type. If
        /// |useCapture| is true (1) then this listener will be considered a
        /// capturing listener. Capturing listeners will recieve all events of
        /// the specified type before the events are dispatched to any other
        /// event targets beneath the current node in the tree. Events which are
        /// bubbling upwards through the tree will not trigger a capturing
        /// listener. Separate calls to this function can be used to register the
        /// same listener with and without capture. See WebCore/dom/EventNames.h
        /// for the list of supported event types.
        /// </summary>
        public IntPtr add_event_listener;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void add_event_listener_delegate(cef_domnode_t* self, /*const*/ cef_string_t* eventType, cef_domevent_listener_t* listener, int useCapture);


        /// The following functions are valid only for element nodes.

        /// <summary>
        /// Returns the tag name of this element.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_element_tag_name;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_element_tag_name_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns true (1) if this element has attributes.
        /// </summary>
        public IntPtr has_element_attributes;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_element_attributes_delegate(cef_domnode_t* self);

        /// <summary>
        /// Returns true (1) if this element has an attribute named |attrName|.
        /// </summary>
        public IntPtr has_element_attribute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int has_element_attribute_delegate(cef_domnode_t* self, /*const*/ cef_string_t* attrName);

        /// <summary>
        /// Returns the element attribute named |attrName|.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_element_attribute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_element_attribute_delegate(cef_domnode_t* self, /*const*/ cef_string_t* attrName);

        /// <summary>
        /// Returns a map of all element attributes.
        /// </summary>
        public IntPtr get_element_attributes;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void get_element_attributes_delegate(cef_domnode_t* self, cef_string_map_t attrMap);

        /// <summary>
        /// Set the value for the element attribute named |attrName|. Returns
        /// true (1) on success.
        /// </summary>
        public IntPtr set_element_attribute;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int set_element_attribute_delegate(cef_domnode_t* self, /*const*/ cef_string_t* attrName, /*const*/ cef_string_t* value);

        /// <summary>
        /// Returns the inner text of the element.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_element_inner_text;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_element_inner_text_delegate(cef_domnode_t* self);

    };


    /// <summary>
    /// Structure used to represent a DOM event. The functions of this structure
    /// should only be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_domevent_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Returns the event type.
        /// </summary>
        /// <remarks>
        /// The resulting string must be freed by calling cef_string_userfree_free().
        /// </remarks>
        public IntPtr get_type;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_string_userfree_t get_type_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns the event category.
        /// </summary>
        public IntPtr get_category;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_dom_event_category_t get_category_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns the event processing phase.
        /// </summary>
        public IntPtr get_phase;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_dom_event_phase_t get_phase_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns true (1) if the event can bubble up the tree.
        /// </summary>
        public IntPtr can_bubble;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int can_bubble_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns true (1) if the event can be canceled.
        /// </summary>
        public IntPtr can_cancel;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate int can_cancel_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns the document associated with this event.
        /// </summary>
        public IntPtr get_document;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domdocument_t* get_document_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns the target of the event.
        /// </summary>
        public IntPtr get_target;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_target_delegate(cef_domevent_t* self);

        /// <summary>
        /// Returns the current target of the event.
        /// </summary>
        public IntPtr get_current_target;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate cef_domnode_t* get_current_target_delegate(cef_domevent_t* self);

    };


    /// <summary>
    /// Structure to implement for handling DOM events. The functions of this
    /// structure will be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_domevent_listener_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Called when an event is received. The event object passed to this
        /// function contains a snapshot of the DOM at the time this function is
        /// executed. DOM objects are only valid for the scope of this function.
        /// Do not keep references to or attempt to access any DOM objects
        /// outside the scope of this function.
        /// </summary>
        public IntPtr handle_event;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void handle_event_delegate(cef_domevent_listener_t* self, cef_domevent_t* @event);

    };


    /// <summary>
    /// Structure to implement for filtering response content. The functions of
    /// this structure will always be called on the UI thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = libcef.StructPack)]
    internal unsafe partial struct cef_content_filter_t
    {
        /// <summary>
        /// Base structure.
        /// </summary>
        public cef_base_t @base;

        /// <summary>
        /// Set |substitute_data| to the replacement for the data in |data| if
        /// data should be modified.
        /// </summary>
        public IntPtr process_data;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void process_data_delegate(cef_content_filter_t* self, /*const*/ void* data, int data_size, cef_stream_reader_t** substitute_data);

        /// <summary>
        /// Called when there is no more data to be processed. It is expected
        /// that whatever data was retained in the last process_data() call, it
        /// should be returned now by setting |remainder| if appropriate.
        /// </summary>
        public IntPtr drain;
        [UnmanagedFunctionPointer(libcef.Callback), SuppressUnmanagedCodeSecurity]
        public delegate void drain_delegate(cef_content_filter_t* self, cef_stream_reader_t** remainder);

    };


}

